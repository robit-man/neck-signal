<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Neck-Phone Controller</title>

<style>
  :root { color-scheme: dark; }
  body {
    margin: 0; background: #111; color: #fafafa;
    font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }
  header {
    position: sticky; top: 0; z-index: 10; background: #111; border-bottom: 1px solid #333;
    display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: .5rem;
    padding: .5rem .75rem;
  }
  #status { font-size: 1.6rem; }
  .actions { display: flex; gap: .5rem; }
  button, input, select {
    background: #181818; color: #fff; border: 1px solid #444; border-radius: .35rem;
    padding: .45rem .7rem; font: inherit;
  }
  button:hover { background: #222; }
  main { max-width: 1200px; margin: 0 auto; padding: .75rem; display: grid; gap: .75rem; }
  .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Roboto Mono", monospace; }
  .panel {
    border: 1px solid #333; border-radius: .5rem; padding: .75rem; background: #121212;
  }
  .muted { opacity: .7; }

  .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; }
  .frame {
    border: 1px solid #222; background: #0a0a0a; border-radius: .35rem; overflow: hidden;
    position: relative;
  }
  .frame .pad {
    /* default reserve 16:9 until first frame sets exact aspect-ratio */
    width: 100%;
    aspect-ratio: 16 / 9;
    background: #0a0a0a;
    display: grid; place-items: center;
  }
  .frame img {
    width: 100%; height: 100%; object-fit: contain; display: block;
    background: #000;
  }

  /* Phone pose (Three.js) */
  #poseWrap {
    border: 1px solid #222; border-radius: .35rem; overflow: hidden;
  }
  #poseCanvas { width: 100%; height: 100%; display: block; }

  /* Settings modal */
  #configDlg[hidden] { display: none; }
  #configDlg {
    position: fixed; inset: 0; background: rgba(0,0,0,.6);
    display: grid; place-items: center;
  }
  #configDlg .card {
    width: min(92vw, 560px); background: #171717; border: 1px solid #333; border-radius: .6rem;
    padding: 1rem; display: grid; gap: .85rem;
  }
  .grid { display: grid; gap: .5rem; }
  .rangeRow {
    display:grid; gap:.5rem; grid-template-columns: 1fr minmax(4.5rem, 6rem);
    align-items:center;
  }
  .flips { display:grid; grid-template-columns: repeat(6, auto); gap:.5rem .75rem; align-items:center; }
</style>

<!-- Socket.IO client (browser bundle) -->
<script src="https://unpkg.com/socket.io-client@4.7.5/dist/socket.io.min.js"></script>

<body>
  <header>
    <div id="status" title="Connection status">🔴</div>

    <div class="actions">
      <button id="btnPerms" title="Request motion/orientation permission (iOS)">Enable Sensors</button>
      <button id="btnCenter" title="Center orientation (set baseline)">Center</button>
      <button id="btnHome" title="Send HOME and pause streaming 5s">HOME</button>
      <button id="btnSettings" title="Open settings">Settings</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="row">
        <div class="muted">Live Feeds</div>
        <div class="muted mono" id="whichRobot" style="margin-left:auto;">robot: —</div>
      </div>

      <div class="grid2">
        <div class="frame">
          <div class="muted mono" style="padding:.4rem .5rem;">Color</div>
          <div id="wrapColor" class="pad"><img id="imgColor" alt="color"></div>
        </div>
        <div class="frame">
          <div class="muted mono" style="padding:.4rem .5rem;">Depth</div>
          <div id="wrapDepth" class="pad"><img id="imgDepth" alt="depth"></div>
        </div>
      </div>

      <div class="grid2" style="margin-top:.75rem;">
        <div id="poseWrap" class="panel" style="min-height: 260px;">
          <div class="muted mono" style="margin-bottom:.5rem;">Phone Pose</div>
          <canvas id="poseCanvas"></canvas>
        </div>
        <div class="panel">
          <div class="row mono">
            <div id="orient">Yaw 0° &nbsp; Pitch 0° &nbsp; Roll 0°</div>
          </div>
          <div class="row mono" style="margin-top:.5rem;">
            <div id="cmd">X0,Y0,Z0,H0,S1,A1,R0,P0</div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Settings / first-run -->
  <div id="configDlg">
    <div class="card">
      <h2 class="mono" style="margin:0;">Connect to signaling</h2>
      <form id="cfgForm" class="grid">
        <label class="grid">
          <span>Signaling Server URL</span>
          <input id="srv" placeholder="https://neck-signal.example.tld" required>
        </label>
        <label class="grid">
          <span>Shared Password</span>
          <input id="pw" placeholder="••••••••" required>
        </label>

        <div class="grid">
          <label>Stream Update Interval</label>
          <div class="rangeRow">
            <input id="rateSlider" type="range" min="10" max="100" step="1">
            <div class="row">
              <input id="rateBox" type="number" min="0.01" max="0.10" step="0.01" class="mono" style="width:5.5rem;">
              <span class="muted">sec</span>
            </div>
          </div>
          <small class="muted">Range 0.01–0.10 seconds (10–100 ms)</small>
        </div>

        <div class="grid">
          <label>Axis Sign Flips</label>
          <div class="flips">
            <label class="row"><input type="checkbox" id="flipX"> X</label>
            <label class="row"><input type="checkbox" id="flipY"> Y</label>
            <label class="row"><input type="checkbox" id="flipZ"> Z</label>
            <label class="row"><input type="checkbox" id="flipH"> H</label>
            <label class="row"><input type="checkbox" id="flipP"> P</label>
            <label class="row"><input type="checkbox" id="flipR"> R</label>
          </div>
          <small class="muted mono">
            X,Y,Z,P,R flip by multiplying with −1. H flip mirrors as (50 − H) to preserve 0..50 range.
          </small>
        </div>

        <div class="row" style="justify-content:flex-end; gap:.5rem;">
          <button type="button" onclick="document.getElementById('configDlg').hidden=true">Close</button>
          <button type="submit" style="background:#0a84ff; border-color:#0a84ff;">Save &amp; Connect</button>
        </div>
      </form>
    </div>
  </div>

<!-- Main logic (module so we can import three.js) -->
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.module.js";

////////////////////////////////////////////////////////////////////////////////
// 0) Utility & globals
////////////////////////////////////////////////////////////////////////////////
const st = localStorage;
const statusEl   = document.getElementById('status');
const orientEl   = document.getElementById('orient');
const cmdEl      = document.getElementById('cmd');
const whichRobot = document.getElementById('whichRobot');

const cfgDlg   = document.getElementById('configDlg');
const srvInp   = document.getElementById('srv');
const pwInp    = document.getElementById('pw');
const rateSlider = document.getElementById('rateSlider');
const rateBox    = document.getElementById('rateBox');

const btnPerms   = document.getElementById('btnPerms');
const btnCenter  = document.getElementById('btnCenter');
const btnSettings= document.getElementById('btnSettings');
const btnHome    = document.getElementById('btnHome');

const imgColor = document.getElementById('imgColor');
const imgDepth = document.getElementById('imgDepth');
const wrapColor = document.getElementById('wrapColor');
const wrapDepth = document.getElementById('wrapDepth');
let urlColor = null, urlDepth = null;

// flips
const flipBoxes = {
  X: document.getElementById('flipX'),
  Y: document.getElementById('flipY'),
  Z: document.getElementById('flipZ'),
  H: document.getElementById('flipH'),
  P: document.getElementById('flipP'),
  R: document.getElementById('flipR'),
};

const SIO_PATH = "/socket.io";  // server default path

let serverURL   = "";
let sharedPW    = "";
let jwtToken    = st.getItem('neck_jwt') || ""; // optional cached JWT
let socket      = null;

// identity / presence
let myUuid = st.getItem('neck_my_uuid') || null;
let targetUuid = st.getItem('neck_target_uuid') || null;
const sidToUuid = new Map();
let subscribedUuid = null;

// orientation baseline + live
let yaw=0, pitch=0, roll=0;
let baseQuat = null;            // THREE.Quaternion
let curQuat  = new THREE.Quaternion();

// acceleration & transient translations
let accel = {x:0,y:0,z:0};
let trans = {Y:0,Z:0,H:0};

// streaming control
let sendIntervalMs = Number(st.getItem('neck_rate_ms') || 100);
let intervalTimer = null;
let pauseUntil = 0;

// sign flip map (multipliers)
const flipsDefault = { X:1, Y:1, Z:1, H:1, P:1, R:1 };
let flips = loadFlips();

// tuning
const GAIN_YAW   = 8;
const GAIN_PITCH = 8;
const GAIN_ROLL  = 8;

const DECAY = 0.90;

// helpers
const clamp   = (v,min,max)=>Math.min(max,Math.max(min,v));
const setStatus = (emoji)=>{ statusEl.textContent = emoji; };
const now = ()=>Date.now();
function loadFlips() { try { return Object.assign({}, flipsDefault, JSON.parse(st.getItem('neck_flips') || '{}')); } catch { return { ...flipsDefault }; } }
function saveFlips() { st.setItem('neck_flips', JSON.stringify(flips)); }
function populateFlipUI(){ for (const k of Object.keys(flipBoxes)) flipBoxes[k].checked = flips[k] === -1; }
for (const k of Object.keys(flipBoxes)) flipBoxes[k].addEventListener('change', () => { flips[k] = flipBoxes[k].checked ? -1 : 1; saveFlips(); });

////////////////////////////////////////////////////////////////////////////////
// 1) iOS / browser sensor permissions
////////////////////////////////////////////////////////////////////////////////
async function requestSensorPermissions() {
  try {
    let p1 = (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function')
      ? await DeviceMotionEvent.requestPermission() : 'granted';
    let p2 = (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function')
      ? await DeviceOrientationEvent.requestPermission() : 'granted';
    if (p1 !== 'granted' || p2 !== 'granted') {
      alert('Motion/orientation permissions were not granted. On iOS, use Safari over HTTPS.');
      return false;
    }
    return true;
  } catch { return true; }
}
btnPerms.addEventListener('click', async () => { const ok = await requestSensorPermissions(); if (ok) btnPerms.disabled = true; });
if (!/iphone|ipad|ipod/i.test(navigator.userAgent)) btnPerms.disabled = true;

////////////////////////////////////////////////////////////////////////////////
// 2) settings modal (persist to localStorage)
////////////////////////////////////////////////////////////////////////////////
srvInp.value = st.getItem('neck_server') || "";
pwInp.value  = st.getItem('neck_pw')     || "";
rateSlider.value = String(sendIntervalMs);
rateBox.value    = (sendIntervalMs/1000).toFixed(2);
populateFlipUI();

document.getElementById('cfgForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  st.setItem('neck_server', srvInp.value.trim());
  st.setItem('neck_pw',     pwInp.value.trim());
  st.setItem('neck_rate_ms', String(sendIntervalMs));
  saveFlips();
  cfgDlg.hidden = true;
  await boot();  // connect after saving
});
btnSettings.addEventListener('click', () => { cfgDlg.hidden = false; });

rateSlider.addEventListener('input', () => {
  sendIntervalMs = parseInt(rateSlider.value, 10);
  rateBox.value = (sendIntervalMs/1000).toFixed(2);
  st.setItem('neck_rate_ms', String(sendIntervalMs));
  scheduleTick();
});
rateBox.addEventListener('change', () => {
  let s = parseFloat(rateBox.value);
  if (Number.isNaN(s)) return;
  s = clamp(s, 0.01, 0.10);
  sendIntervalMs = Math.round(s * 1000);
  rateSlider.value = String(sendIntervalMs);
  st.setItem('neck_rate_ms', String(sendIntervalMs));
  scheduleTick();
});

if (srvInp.value && pwInp.value) { cfgDlg.hidden = true; boot(); }

////////////////////////////////////////////////////////////////////////////////
// 3) DeviceOrientation → Quaternion (true orientation) + Three.js pose
////////////////////////////////////////////////////////////////////////////////
const rad = THREE.MathUtils.degToRad;
const deg = THREE.MathUtils.radToDeg;
const corrQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), -Math.PI/2);

// Build corrected quaternion from (alpha, beta, gamma)
function deviceToQuat(alpha, beta, gamma) {
  // As per your reference: Euler(b, a, -g, "YXZ") then correct around X by -π/2
  const e = new THREE.Euler(rad(beta), rad(alpha), -rad(gamma), 'YXZ');
  const q = new THREE.Quaternion().setFromEuler(e);
  q.multiply(corrQuat);
  return q;
}

// Scene
const poseCanvas = document.getElementById('poseCanvas');
const renderer = new THREE.WebGLRenderer({ canvas: poseCanvas, antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a0a);
const cam = new THREE.PerspectiveCamera(55, 16/9, 0.1, 50);
cam.position.set(0, 0.8, 2.2);
scene.add(cam);

const light = new THREE.HemisphereLight(0xffffff, 0x222222, 1.0);
scene.add(light);
const dir = new THREE.DirectionalLight(0xffffff, 0.3);
dir.position.set(1,1,1);
scene.add(dir);

// Phone “slab”
const phoneGeom = new THREE.BoxGeometry(0.7, 1.4, 0.05);
const phoneMat  = new THREE.MeshStandardMaterial({ color: 0x2e6cff, metalness: 0.1, roughness: 0.9 });
const phoneMesh = new THREE.Mesh(phoneGeom, phoneMat);
scene.add(phoneMesh);

// A ground grid for reference
const grid = new THREE.GridHelper(10, 10, 0x333333, 0x222222);
grid.position.y = -1;
scene.add(grid);

function resizePose() {
  const rect = poseCanvas.parentElement.getBoundingClientRect();
  const w = Math.max(300, rect.width);
  const h = Math.max(220, rect.height - 24);
  renderer.setSize(w, h, false);
  cam.aspect = w / h;
  cam.updateProjectionMatrix();
}
window.addEventListener('resize', resizePose);
resizePose();

function renderLoop() {
  renderer.render(scene, cam);
  requestAnimationFrame(renderLoop);
}
renderLoop();

window.addEventListener('deviceorientation', e => {
  if (e.alpha == null) return;
  yaw   = e.alpha;   // raw, only for display
  pitch = e.beta;
  roll  = e.gamma;

  // true orientation from quaternion
  curQuat.copy(deviceToQuat(yaw, pitch, roll));
  phoneMesh.setRotationFromQuaternion(curQuat);

  // update HUD with raw angles (just informational)
  orientEl.textContent = `Yaw ${yaw.toFixed(0)}°  Pitch ${pitch.toFixed(0)}°  Roll ${roll.toFixed(0)}°`;
}, true);

// Acceleration for transient translation
window.addEventListener('devicemotion', e => {
  let a = e.acceleration && (e.acceleration.x!=null) ? e.acceleration : e.accelerationIncludingGravity;
  if (a) accel = { x: a.x || 0, y: a.y || 0, z: a.z || 0 };
}, true);

btnCenter.addEventListener('click', () => { baseQuat = curQuat.clone(); });

////////////////////////////////////////////////////////////////////////////////
// 4) HOME button: send and pause streaming for 5s
////////////////////////////////////////////////////////////////////////////////
btnHome.addEventListener('click', () => {
  if (!socket || socket.disconnected) return;
  trans = {Y:0,Z:0,H:0};
  cmdEl.textContent = "HOME";
  socket.emit('broadcast-message', { message: "HOME" });
  pauseUntil = now() + 5000;
});

////////////////////////////////////////////////////////////////////////////////
// 5) Build command from RELATIVE quaternion yaw/pitch/roll + transients
////////////////////////////////////////////////////////////////////////////////
function getRelativeYPRDeg() {
  if (!baseQuat) return { yaw:0, pitch:0, roll:0 };
  const invBase = baseQuat.clone().invert();
  const rel = invBase.multiply(curQuat);                // q_rel = base^-1 * current
  const e = new THREE.Euler().setFromQuaternion(rel, 'YXZ'); // yaw(Y), pitch(X), roll(Z)
  return {
    yaw:   deg(e.y),     // degrees
    pitch: deg(e.x),
    roll:  deg(e.z),
  };
}

function decay(v){ return Math.abs(v) < 1 ? 0 : v*DECAY; }

function tick() {
  if (!socket || socket.disconnected) return;
  if (now() < pauseUntil) return;

  // transient translations from accel
  trans.Z = clamp(decay(trans.Z + (-accel.y*10)), -400, 400);  // forward/back
  trans.H = clamp(decay(trans.H + ( accel.z* 2)),   0,  50);   // up/down
  trans.Y = clamp(decay(trans.Y + ( accel.x*10)), -400, 400);  // left/right

  const { yaw: yDeg, pitch: pDeg, roll: rDeg } = getRelativeYPRDeg();

  // Map to command ranges with your sign conventions:
  // X: negative = look right, positive = look left
  const X = clamp(-yDeg * GAIN_YAW,   -400, 400);
  const P = clamp( pDeg * GAIN_PITCH, -400, 400);    // + up, − down
  const R = clamp( rDeg * GAIN_ROLL,  -400, 400);    // − right tilt, + left tilt

  // apply sign flips
  const Xo = flips.X * X;
  const Yo = flips.Y * trans.Y;
  const Zo = flips.Z * trans.Z;
  let   Ho = trans.H;
  if (flips.H === -1) Ho = 50 - Ho;     // mirror within 0..50
  Ho = clamp(Ho, 0, 50);
  const Po = flips.P * P;
  const Ro = flips.R * R;

  const cmd = `X${Xo.toFixed(0)},Y${Yo.toFixed(0)},Z${Zo.toFixed(0)},H${Ho.toFixed(0)},S1,A1,R${Ro.toFixed(0)},P${Po.toFixed(0)}`;
  cmdEl.textContent = cmd;
  socket.emit('broadcast-message', { message: cmd });
}

function scheduleTick() {
  if (intervalTimer) clearInterval(intervalTimer);
  intervalTimer = setInterval(tick, sendIntervalMs);
}
scheduleTick();

////////////////////////////////////////////////////////////////////////////////
// 6) Frames: respect aspect ratio based on actual frame sizes
////////////////////////////////////////////////////////////////////////////////
function updateImg(imgEl, wrapEl, oldUrlRefName, payload, mime) {
  const blob = payload instanceof Blob ? payload : new Blob([payload], { type: mime });
  const url = URL.createObjectURL(blob);
  const tmp = new Image();
  tmp.onload = () => {
    // Update wrapper aspect ratio using real dimensions
    wrapEl.style.aspectRatio = `${tmp.naturalWidth} / ${tmp.naturalHeight}`;
    URL.revokeObjectURL(tmp.src);
  };
  tmp.src = url;

  imgEl.onload = () => { /* nothing; image shows with object-fit: contain */ };
  imgEl.src = url;

  if (window[oldUrlRefName]) URL.revokeObjectURL(window[oldUrlRefName]);
  window[oldUrlRefName] = url;
}

function unsubscribeDynamic() {
  if (!socket || !subscribedUuid) return;
  socket.off(`/${subscribedUuid}_color`);
  socket.off(`/${subscribedUuid}_depth`);
  subscribedUuid = null;
}

function subscribeDynamic(uuid) {
  if (!socket) return;
  if (subscribedUuid === uuid) return;
  unsubscribeDynamic();
  subscribedUuid = uuid;
  whichRobot.textContent = `robot: ${uuid}`;
  socket.on(`/${uuid}_color`, (payload) => updateImg(imgColor, wrapColor, 'urlColor', payload, 'image/jpeg'));
  socket.on(`/${uuid}_depth`, (payload) => updateImg(imgDepth, wrapDepth, 'urlDepth', payload, 'image/png'));
}

// Fallback legacy (if no uuid-specific streams)
function wireLegacyHandlers(s) {
  s.off('frame-color'); s.off('frame-depth');
  s.on('frame-color', (payload) => { if (!subscribedUuid) updateImg(imgColor, wrapColor, 'urlColor', payload, 'image/jpeg'); });
  s.on('frame-depth', (payload) => { if (!subscribedUuid) updateImg(imgDepth, wrapDepth, 'urlDepth', payload, 'image/png'); });
}

////////////////////////////////////////////////////////////////////////////////
// 7) Presence & WS auth (JWT or ws+password)
////////////////////////////////////////////////////////////////////////////////
function chooseTargetFromList(list) {
  sidToUuid.clear();
  list.forEach(p => { if (p.id && p.uuid) sidToUuid.set(p.id, p.uuid); });

  if (targetUuid && [...sidToUuid.values()].includes(targetUuid)) {
    subscribeDynamic(targetUuid);
    return;
  }
  const candidates = list.filter(p => p.uuid && p.uuid !== myUuid);
  if (candidates.length > 0) {
    targetUuid = candidates[0].uuid;
    st.setItem('neck_target_uuid', targetUuid);
    subscribeDynamic(targetUuid);
  } else {
    whichRobot.textContent = 'robot: —';
    unsubscribeDynamic();
  }
}

function wirePresenceHandlers(s) {
  s.on('existing-peers', (arr) => chooseTargetFromList(arr || []));
  s.on('new-peer', (info) => {
    if (info && info.id && info.uuid) {
      sidToUuid.set(info.id, info.uuid);
      if (!targetUuid && info.uuid !== myUuid) {
        targetUuid = info.uuid; st.setItem('neck_target_uuid', targetUuid);
        subscribeDynamic(targetUuid);
      }
    }
  });
  s.on('peer-disconnect', (sid) => {
    const u = sidToUuid.get(sid);
    sidToUuid.delete(sid);
    if (u && u === targetUuid) {
      targetUuid = null; st.removeItem('neck_target_uuid');
      whichRobot.textContent = 'robot: —';
      unsubscribeDynamic();
    }
  });
}

function wireCommonHandlers(s) {
  s.on('connect',      () => setStatus('🟢'));
  s.on('disconnect',   () => { setStatus('🔴'); whichRobot.textContent = 'robot: —'; });
  s.on('connect_error',() => setStatus('🔴'));
  wirePresenceHandlers(s);
  wireLegacyHandlers(s);
}

function connectWS_withToken() {
  return new Promise((resolve,reject)=>{
    const s = io(serverURL, { path: SIO_PATH, auth: { token: jwtToken }, transports: ['websocket'] });
    let settled = false;
    wireCommonHandlers(s);
    s.on('connect', () => { socket = s; setStatus('🟢'); settled = true; resolve('token'); });
    s.on('connect_error',(err) => { if (!settled) { s.close(); reject(err); } });
  });
}
function connectWS_withPassword() {
  return new Promise((resolve,reject)=>{
    const uuid = 'phone-' + Date.now().toString(36);
    myUuid = uuid; st.setItem('neck_my_uuid', myUuid);
    const s = io(serverURL, { path: SIO_PATH, auth: { uuid, password: sharedPW }, transports: ['websocket'] });
    let settled = false;
    wireCommonHandlers(s);
    s.on('connect', () => { socket = s; setStatus('🟢'); settled = true; resolve('password'); });
    s.on('connect_error',(err) => { if (!settled) { s.close(); reject(err); } });
  });
}

////////////////////////////////////////////////////////////////////////////////
async function boot() {
  serverURL = (st.getItem('neck_server') || "").trim().replace(/\/+$/, '');
  sharedPW  = (st.getItem('neck_pw')     || "").trim();
  if (!serverURL || !sharedPW) { cfgDlg.hidden = false; return; }

  setStatus('🟡');

  if (!window.isSecureContext && /iphone|ipad|ipod/i.test(navigator.userAgent)) {
    alert("iOS sensors require HTTPS. Open this page via https.");
  }

  try {
    if (jwtToken) { await connectWS_withToken(); }
    else          { await connectWS_withPassword(); }
  } catch {
    try { await connectWS_withPassword(); }
    catch (ee) { console.error('WS connect failed:', ee); setStatus('🔴'); }
  }

  // auto-baseline once after 1s if not already
  setTimeout(() => { if (!baseQuat) baseQuat = curQuat.clone(); }, 1000);
}

// auto-show settings on first load
if (!(st.getItem('neck_server') && st.getItem('neck_pw'))) cfgDlg.hidden = false;
else boot();
</script>
</body>
</html>
