<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Neck-Phone Controller</title>

<style>
  :root { color-scheme: dark; }
  body {
    margin: 0; background: #111; color: #fafafa;
    font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }
  header {
    position: sticky; top: 0; z-index: 10; background: #111; border-bottom: 1px solid #333;
    display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: .5rem;
    padding: .5rem .75rem;
  }
  #status { font-size: 1.6rem; }
  .actions { display: flex; gap: .5rem; }
  button, input, select {
    background: #181818; color: #fff; border: 1px solid #444; border-radius: .35rem;
    padding: .45rem .7rem; font: inherit;
  }
  button:hover { background: #222; }
  main { max-width: 1100px; margin: 0 auto; padding: .75rem; display: grid; gap: .75rem; }
  .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Roboto Mono", monospace; }
  .panel {
    border: 1px solid #333; border-radius: .5rem; padding: .75rem; background: #121212;
  }
  .images { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; }
  .images img { width: 100%; height: auto; display: block; background: #0a0a0a; border: 1px solid #222; }
  .muted { opacity: .7; }

  /* Settings modal */
  #configDlg[hidden] { display: none; }
  #configDlg {
    position: fixed; inset: 0; background: rgba(0,0,0,.6);
    display: grid; place-items: center;
  }
  #configDlg .card {
    width: min(92vw, 560px); background: #171717; border: 1px solid #333; border-radius: .6rem;
    padding: 1rem; display: grid; gap: .85rem;
  }
  .grid { display: grid; gap: .5rem; }
  label small { display:block; opacity:.8; }
  .rangeRow {
    display:grid; gap:.5rem; grid-template-columns: 1fr minmax(4.5rem, 6rem);
    align-items:center;
  }
  .flips { display:grid; grid-template-columns: repeat(6, auto); gap:.5rem .75rem; align-items:center; }
</style>

<!-- Socket.IO client (browser bundle) -->
<script src="https://unpkg.com/socket.io-client@4.7.5/dist/socket.io.min.js"></script>

<body>
  <header>
    <div id="status" title="Connection status">ðŸ”´</div>

    <div class="actions">
      <button id="btnPerms" title="Request motion/orientation permission (iOS)">Enable Sensors</button>
      <button id="btnCenter" title="Center orientation (set baseline)">Center</button>
      <button id="btnHome" title="Send HOME and pause streaming 5s">HOME</button>
      <button id="btnSettings" title="Open settings">Settings</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="row">
        <div class="muted">Live Feeds</div>
        <div class="muted mono" id="whichRobot" style="margin-left:auto;">robot: â€”</div>
      </div>
      <div class="images">
        <div>
          <div class="muted mono">Color</div>
          <img id="imgColor" alt="color stream">
        </div>
        <div>
          <div class="muted mono">Depth</div>
          <img id="imgDepth" alt="depth stream">
        </div>
      </div>
      <div class="row mono">
        <div id="orient" class="panel">Yaw 0Â° &nbsp; Pitch 0Â° &nbsp; Roll 0Â°</div>
        <div id="cmd" class="panel">X0,Y0,Z0,H0,S1,A1,R0,P0</div>
      </div>
    </section>
  </main>

  <!-- Settings / first-run -->
  <div id="configDlg">
    <div class="card">
      <h2 class="mono" style="margin:0;">Connect to signaling</h2>
      <form id="cfgForm" class="grid">
        <label class="grid">
          <span>Signaling Server URL</span>
          <input id="srv" placeholder="https://neck-signal.example.tld" required>
        </label>
        <label class="grid">
          <span>Shared Password</span>
          <input id="pw" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" required>
        </label>

        <div class="grid">
          <label>Stream Update Interval</label>
          <div class="rangeRow">
            <input id="rateSlider" type="range" min="10" max="100" step="1">
            <div class="row">
              <input id="rateBox" type="number" min="0.01" max="0.10" step="0.01" class="mono" style="width:5.5rem;">
              <span class="muted">sec</span>
            </div>
          </div>
          <small class="muted">Range 0.01â€“0.10 seconds (10â€“100 ms)</small>
        </div>

        <div class="grid">
          <label>Axis Sign Flips</label>
          <div class="flips">
            <label class="row"><input type="checkbox" id="flipX"> X</label>
            <label class="row"><input type="checkbox" id="flipY"> Y</label>
            <label class="row"><input type="checkbox" id="flipZ"> Z</label>
            <label class="row"><input type="checkbox" id="flipH"> H</label>
            <label class="row"><input type="checkbox" id="flipP"> P</label>
            <label class="row"><input type="checkbox" id="flipR"> R</label>
          </div>
          <small class="muted mono">
            X,Y,Z,P,R flip by multiplying with âˆ’1. H flip mirrors as (50 âˆ’ H) to preserve 0..50 range.
          </small>
        </div>

        <div class="row" style="justify-content:flex-end; gap:.5rem;">
          <button type="button" onclick="document.getElementById('configDlg').hidden=true">Close</button>
          <button type="submit" style="background:#0a84ff; border-color:#0a84ff;">Save &amp; Connect</button>
        </div>
      </form>
    </div>
  </div>

<script>
////////////////////////////////////////////////////////////////////////////////
// 0) Utility & globals
////////////////////////////////////////////////////////////////////////////////
const st = localStorage;
const statusEl   = document.getElementById('status');
const orientEl   = document.getElementById('orient');
const cmdEl      = document.getElementById('cmd');
const whichRobot = document.getElementById('whichRobot');

const cfgDlg   = document.getElementById('configDlg');
const srvInp   = document.getElementById('srv');
const pwInp    = document.getElementById('pw');
const rateSlider = document.getElementById('rateSlider');
const rateBox    = document.getElementById('rateBox');

const btnPerms   = document.getElementById('btnPerms');
const btnCenter  = document.getElementById('btnCenter');
const btnSettings= document.getElementById('btnSettings');
const btnHome    = document.getElementById('btnHome');

const imgColor = document.getElementById('imgColor');
const imgDepth = document.getElementById('imgDepth');
let urlColor = null, urlDepth = null;

const flipBoxes = {
  X: document.getElementById('flipX'),
  Y: document.getElementById('flipY'),
  Z: document.getElementById('flipZ'),
  H: document.getElementById('flipH'),
  P: document.getElementById('flipP'),
  R: document.getElementById('flipR'),
};

const SIO_PATH = "/socket.io";  // server default path

let serverURL   = "";
let sharedPW    = "";
let jwtToken    = st.getItem('neck_jwt') || ""; // optional cached JWT
let socket      = null;

// identity / presence
let myUuid = st.getItem('neck_my_uuid') || null;
let targetUuid = st.getItem('neck_target_uuid') || null;
const sidToUuid = new Map();
let subscribedUuid = null;

// orientation baseline + live values (deg)
let baseYaw=null, basePitch=null, baseRoll=null;
let yaw=0, pitch=0, roll=0;

// acceleration & transient translations
let accel = {x:0,y:0,z:0};
let trans = {Y:0,Z:0,H:0};

// streaming control
let sendIntervalMs = Number(st.getItem('neck_rate_ms') || 100); // default 100ms
let intervalTimer = null;
let pauseUntil = 0; // ms timestamp; while in the future, streaming is paused

// sign flip map (multipliers)
const flipsDefault = { X:1, Y:1, Z:1, H:1, P:1, R:1 };
let flips = loadFlips();

// tuning
const GAIN_YAW   = 8;   // deg â†’ units
const GAIN_PITCH = 8;
const GAIN_ROLL  = 8;

const DECAY = 0.90;     // exponential decay for transients

// helpers
const clamp   = (v,min,max)=>Math.min(max,Math.max(min,v));
const setStatus = (emoji)=>{ statusEl.textContent = emoji; };
const wrap180 = a => ((a+540)%360)-180;          // normalize to (-180,180]
const now = ()=>Date.now();

function loadFlips() {
  try { return Object.assign({}, flipsDefault, JSON.parse(st.getItem('neck_flips') || '{}')); }
  catch { return { ...flipsDefault }; }
}
function saveFlips() { st.setItem('neck_flips', JSON.stringify(flips)); }
function populateFlipUI(){
  for (const k of Object.keys(flipBoxes)) flipBoxes[k].checked = flips[k] === -1;
}
for (const k of Object.keys(flipBoxes)) {
  flipBoxes[k].addEventListener('change', () => {
    flips[k] = flipBoxes[k].checked ? -1 : 1;
    saveFlips();
  });
}

////////////////////////////////////////////////////////////////////////////////
// 1) iOS / browser sensor permissions
////////////////////////////////////////////////////////////////////////////////
async function requestSensorPermissions() {
  try {
    let p1 = (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function')
      ? await DeviceMotionEvent.requestPermission() : 'granted';
    let p2 = (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function')
      ? await DeviceOrientationEvent.requestPermission() : 'granted';
    if (p1 !== 'granted' || p2 !== 'granted') {
      alert('Motion/orientation permissions were not granted. On iOS, use Safari over HTTPS.');
      return false;
    }
    return true;
  } catch { return true; }
}
btnPerms.addEventListener('click', async () => {
  const ok = await requestSensorPermissions();
  if (ok) btnPerms.disabled = true;
});
if (!/iphone|ipad|ipod/i.test(navigator.userAgent)) btnPerms.disabled = true;

////////////////////////////////////////////////////////////////////////////////
// 2) settings modal (persist to localStorage)
////////////////////////////////////////////////////////////////////////////////
srvInp.value = st.getItem('neck_server') || "";
pwInp.value  = st.getItem('neck_pw')     || "";
rateSlider.value = String(sendIntervalMs);
rateBox.value    = (sendIntervalMs/1000).toFixed(2);
populateFlipUI();

document.getElementById('cfgForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  st.setItem('neck_server', srvInp.value.trim());
  st.setItem('neck_pw',     pwInp.value.trim());
  st.setItem('neck_rate_ms', String(sendIntervalMs));
  saveFlips();
  cfgDlg.hidden = true;
  await boot();  // connect after saving
});

btnSettings.addEventListener('click', () => { cfgDlg.hidden = false; });

rateSlider.addEventListener('input', () => {
  sendIntervalMs = parseInt(rateSlider.value, 10);
  rateBox.value = (sendIntervalMs/1000).toFixed(2);
  st.setItem('neck_rate_ms', String(sendIntervalMs));
  scheduleTick();
});
rateBox.addEventListener('change', () => {
  let s = parseFloat(rateBox.value);
  if (Number.isNaN(s)) return;
  s = clamp(s, 0.01, 0.10);
  sendIntervalMs = Math.round(s * 1000);
  rateSlider.value = String(sendIntervalMs);
  st.setItem('neck_rate_ms', String(sendIntervalMs));
  scheduleTick();
});

if (srvInp.value && pwInp.value) {
  cfgDlg.hidden = true;
  boot(); // autoconnect on revisit
}

////////////////////////////////////////////////////////////////////////////////
// 3) live sensors (Yaw(Î±)â†’X, Pitch(Î²)â†’P, Roll(Î³)â†’R with wrap)
////////////////////////////////////////////////////////////////////////////////
window.addEventListener('deviceorientation', e => {
  if (e.alpha != null) {
    // Î± = yaw (0..360), Î² = pitch (-180..180), Î³ = roll (-90..90)
    yaw   = e.alpha;
    pitch = e.beta;
    roll  = e.gamma;
    orientEl.textContent = `Yaw ${yaw.toFixed(0)}Â°  Pitch ${pitch.toFixed(0)}Â°  Roll ${roll.toFixed(0)}Â°`;
  }
}, true);

window.addEventListener('devicemotion', e => {
  let a = e.acceleration && (e.acceleration.x!=null) ? e.acceleration : e.accelerationIncludingGravity;
  if (a) accel = { x: a.x || 0, y: a.y || 0, z: a.z || 0 };
}, true);

btnCenter.addEventListener('click', () => {
  baseYaw = yaw; basePitch = pitch; baseRoll = roll;
});

function getRelativeAngles() {
  if (baseYaw==null || basePitch==null || baseRoll==null) return {X:0,P:0,R:0};
  // wrap-around friendly deltas (360 â†” 0 handled)
  const dYaw   = wrap180(yaw   - baseYaw);
  const dPitch = wrap180(pitch - basePitch);
  const dRoll  = wrap180(roll  - baseRoll);

  // map to command ranges (with your sign conventions):
  // X: negative = look right, positive = look left
  const X = clamp(-dYaw   * GAIN_YAW  , -400, 400);
  // P: + up, - down
  const P = clamp( dPitch * GAIN_PITCH, -400, 400);
  // R: - right tilt, + left tilt
  const R = clamp( dRoll  * GAIN_ROLL , -400, 400);
  return {X,P,R};
}

////////////////////////////////////////////////////////////////////////////////
// 4) HOME button: send and pause streaming for 5s
////////////////////////////////////////////////////////////////////////////////
btnHome.addEventListener('click', () => {
  if (!socket || socket.disconnected) return;
  trans = {Y:0,Z:0,H:0};
  cmdEl.textContent = "HOME";
  socket.emit('broadcast-message', { message: "HOME" });
  pauseUntil = now() + 5000;
});

////////////////////////////////////////////////////////////////////////////////
// 5) command synthesis & streaming (adjustable interval)
////////////////////////////////////////////////////////////////////////////////
function decay(v){ return Math.abs(v) < 1 ? 0 : v*DECAY; }

function tick() {
  if (!socket || socket.disconnected) return;
  if (now() < pauseUntil) return; // paused after HOME

  // motion impulses â†’ transient translations
  //   forward/back  : accel.y -> Z (âˆ’ forward, + backward)
  //   up/down       : accel.z -> H (0..50)
  //   left/right    : accel.x -> Y (âˆ’ left, + right)
  trans.Z = clamp(decay(trans.Z + (-accel.y*10)), -400, 400);
  trans.H = clamp(decay(trans.H + ( accel.z* 2)),   0,  50);
  trans.Y = clamp(decay(trans.Y + ( accel.x*10)), -400, 400);

  const {X, P, R} = getRelativeAngles();

  // apply sign flips
  const Xo = flips.X * X;
  const Yo = flips.Y * trans.Y;
  const Zo = flips.Z * trans.Z;
  let   Ho = trans.H;
  if (flips.H === -1) Ho = 50 - Ho;     // mirror within 0..50
  Ho = clamp(Ho, 0, 50);
  const Po = flips.P * P;
  const Ro = flips.R * R;

  const cmd = `X${Xo.toFixed(0)},Y${Yo.toFixed(0)},Z${Zo.toFixed(0)},` +
              `H${Ho.toFixed(0)},S1,A1,R${Ro.toFixed(0)},P${Po.toFixed(0)}`;
  cmdEl.textContent = cmd;

  socket.emit('broadcast-message', { message: cmd });
}

function scheduleTick() {
  if (intervalTimer) clearInterval(intervalTimer);
  intervalTimer = setInterval(tick, sendIntervalMs);
}
scheduleTick();

////////////////////////////////////////////////////////////////////////////////
// 6) frames: dynamic per-robot subscriptions
////////////////////////////////////////////////////////////////////////////////
function updateImg(imgEl, oldUrlRefName, payload, mime) {
  const blob = payload instanceof Blob ? payload : new Blob([payload], { type: mime });
  const url = URL.createObjectURL(blob);
  imgEl.src = url;
  if (window[oldUrlRefName]) URL.revokeObjectURL(window[oldUrlRefName]);
  window[oldUrlRefName] = url;
}

function unsubscribeDynamic() {
  if (!socket || !subscribedUuid) return;
  socket.off(`/${subscribedUuid}_color`);
  socket.off(`/${subscribedUuid}_depth`);
  subscribedUuid = null;
}

function subscribeDynamic(uuid) {
  if (!socket) return;
  if (subscribedUuid === uuid) return;
  unsubscribeDynamic();
  subscribedUuid = uuid;
  whichRobot.textContent = `robot: ${uuid}`;
  socket.on(`/${uuid}_color`, (payload) => updateImg(imgColor, 'urlColor', payload, 'image/jpeg'));
  socket.on(`/${uuid}_depth`, (payload) => updateImg(imgDepth, 'urlDepth', payload, 'image/png'));
}

// Fallback legacy handlers if no target robot is known
function wireLegacyHandlers(s) {
  s.off('frame-color'); s.off('frame-depth');
  s.on('frame-color', (payload) => { if (!subscribedUuid) updateImg(imgColor, 'urlColor', payload, 'image/jpeg'); });
  s.on('frame-depth', (payload) => { if (!subscribedUuid) updateImg(imgDepth, 'urlDepth', payload, 'image/png'); });
}

function chooseTargetFromList(list) {
  // track sidâ†’uuid map
  sidToUuid.clear();
  list.forEach(p => { if (p.id && p.uuid) sidToUuid.set(p.id, p.uuid); });

  // keep target if still present
  if (targetUuid && [...sidToUuid.values()].includes(targetUuid)) {
    subscribeDynamic(targetUuid);
    return;
  }

  // pick first other (not me)
  const candidates = list.filter(p => p.uuid && p.uuid !== myUuid);
  if (candidates.length > 0) {
    targetUuid = candidates[0].uuid;
    st.setItem('neck_target_uuid', targetUuid);
    subscribeDynamic(targetUuid);
  } else {
    // nobody to subscribe â€” show legacy if agent broadcasts there
    whichRobot.textContent = 'robot: â€”';
    unsubscribeDynamic();
  }
}

////////////////////////////////////////////////////////////////////////////////
// 7) networking: WS-only auth (JWT if present; else ws+password)
////////////////////////////////////////////////////////////////////////////////
function wirePresenceHandlers(s) {
  s.on('existing-peers', (arr) => chooseTargetFromList(arr || []));
  s.on('new-peer', (info) => {
    if (info && info.id && info.uuid) {
      sidToUuid.set(info.id, info.uuid);
      if (!targetUuid && info.uuid !== myUuid) {
        targetUuid = info.uuid; st.setItem('neck_target_uuid', targetUuid);
        subscribeDynamic(targetUuid);
      }
    }
  });
  s.on('peer-disconnect', (sid) => {
    const u = sidToUuid.get(sid);
    sidToUuid.delete(sid);
    if (u && u === targetUuid) {
      targetUuid = null; st.removeItem('neck_target_uuid');
      whichRobot.textContent = 'robot: â€”';
      unsubscribeDynamic();
    }
  });
}

function wireCommonHandlers(s) {
  s.on('connect',      () => setStatus('ðŸŸ¢'));
  s.on('disconnect',   () => { setStatus('ðŸ”´'); whichRobot.textContent = 'robot: â€”'; });
  s.on('connect_error',() => setStatus('ðŸ”´'));
  wirePresenceHandlers(s);
  wireLegacyHandlers(s);
}

function connectWS_withToken() {
  return new Promise((resolve,reject)=>{
    const s = io(serverURL, {
      path: SIO_PATH,
      auth: { token: jwtToken },
      transports: ['websocket']
    });
    let settled = false;
    wireCommonHandlers(s);
    s.on('connect', () => { socket = s; setStatus('ðŸŸ¢'); settled = true; resolve('token'); });
    s.on('connect_error',(err) => { if (!settled) { s.close(); reject(err); } });
  });
}

function connectWS_withPassword() {
  return new Promise((resolve,reject)=>{
    const uuid = 'phone-' + Date.now().toString(36);
    myUuid = uuid; st.setItem('neck_my_uuid', myUuid);
    const s = io(serverURL, {
      path: SIO_PATH,
      auth: { uuid, password: sharedPW },
      transports: ['websocket']
    });
    let settled = false;
    wireCommonHandlers(s);
    s.on('connect', () => { socket = s; setStatus('ðŸŸ¢'); settled = true; resolve('password'); });
    s.on('connect_error',(err) => { if (!settled) { s.close(); reject(err); } });
  });
}

////////////////////////////////////////////////////////////////////////////////
async function boot() {
  serverURL = (st.getItem('neck_server') || "").trim().replace(/\/+$/, '');
  sharedPW  = (st.getItem('neck_pw')     || "").trim();
  if (!serverURL || !sharedPW) { cfgDlg.hidden = false; return; }

  setStatus('ðŸŸ¡');

  // iOS sensors require HTTPS
  if (!window.isSecureContext && /iphone|ipad|ipod/i.test(navigator.userAgent)) {
    alert("iOS sensors require HTTPS. Open this page via https.");
  }

  try {
    if (jwtToken) {
      await connectWS_withToken();
    } else {
      await connectWS_withPassword();
    }
  } catch {
    try { await connectWS_withPassword(); }
    catch (ee) { console.error('WS connect failed:', ee); setStatus('ðŸ”´'); }
  }

  // auto-calibrate once after 1s if not already done
  setTimeout(() => { if (baseYaw==null) btnCenter.click(); }, 1000);
}

// auto-show settings on first load
if (!(st.getItem('neck_server') && st.getItem('neck_pw'))) cfgDlg.hidden = false;
else boot();
</script>
</body>
</html>
