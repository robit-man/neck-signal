<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Neck-Phone Controller</title>

<style>
  :root { color-scheme: dark; }
  body {
    margin: 0; background: #111; color: #fafafa;
    font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }
  header {
    position: sticky; top: 0; z-index: 10; background: #111; border-bottom: 1px solid #333;
    display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: .5rem;
    padding: .5rem .75rem;
  }
  #status { font-size: 1.6rem; }
  .actions { display: flex; gap: .5rem; }
  button, input, select {
    background: #181818; color: #fff; border: 1px solid #444; border-radius: .35rem;
    padding: .45rem .7rem; font: inherit;
  }
  button:hover { background: #222; }
  main { max-width: 1100px; margin: 0 auto; padding: .75rem; display: grid; gap: .75rem; }
  .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Roboto Mono", monospace; }
  .panel {
    border: 1px solid #333; border-radius: .5rem; padding: .75rem; background: #121212;
  }
  .images { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; }
  .images img { width: 100%; height: auto; display: block; background: #0a0a0a; border: 1px solid #222; }

  /* Settings modal */
  #configDlg[hidden] { display: none; }
  #configDlg {
    position: fixed; inset: 0; background: rgba(0,0,0,.6);
    display: grid; place-items: center;
  }
  #configDlg .card {
    width: min(92vw, 540px); background: #171717; border: 1px solid #333; border-radius: .6rem;
    padding: 1rem; display: grid; gap: .75rem;
  }
  .grid { display: grid; gap: .5rem; }
  label small { display:block; opacity:.8; }
  .rangeRow {
    display:grid; gap:.5rem; grid-template-columns: 1fr minmax(4.5rem, 6rem);
    align-items:center;
  }
  .muted { opacity: .7; }
</style>

<!-- Socket.IO client (browser build) -->
<script src="https://unpkg.com/socket.io-client@4.7.5/dist/socket.io.min.js"></script>

<body>
  <header>
    <div id="status" title="Connection status">ðŸ”´</div>
    <div class="row mono">
      <div id="orient" class="panel">Yaw 0Â° &nbsp; Pitch 0Â° &nbsp; Roll 0Â°</div>
      <div id="cmd" class="panel">X0,Y0,Z0,H0,S1,A1,R0,P0</div>
    </div>
    <div class="actions">
      <button id="btnPerms" title="Request motion/orientation permission (iOS)">Enable Sensors</button>
      <button id="btnCenter" title="Center orientation (set baseline)">Center</button>
      <button id="btnHome" title="Send HOME and pause streaming 5s">HOME</button>
      <button id="btnSettings" title="Open settings">Settings</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="row">
        <div class="muted">Live Feeds</div>
      </div>
      <div class="images">
        <div>
          <div class="muted mono">Color</div>
          <img id="imgColor" alt="color stream">
        </div>
        <div>
          <div class="muted mono">Depth</div>
          <img id="imgDepth" alt="depth stream">
        </div>
      </div>
    </section>
  </main>

  <!-- Settings / first-run -->
  <div id="configDlg">
    <div class="card">
      <h2 class="mono" style="margin:0;">Connect to signaling</h2>
      <form id="cfgForm" class="grid">
        <label class="grid">
          <span>Signaling Server URL</span>
          <input id="srv" placeholder="https://neck-signal.example.tld" required>
        </label>
        <label class="grid">
          <span>Shared Password</span>
          <input id="pw" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" required>
        </label>

        <div class="grid">
          <label>Stream Update Interval</label>
          <div class="rangeRow">
            <input id="rateSlider" type="range" min="10" max="100" step="1">
            <div class="row">
              <input id="rateBox" type="number" min="0.01" max="0.10" step="0.01" class="mono" style="width:5.5rem;">
              <span class="muted">sec</span>
            </div>
          </div>
          <small class="muted">Range 0.01â€“0.10 seconds (10â€“100 ms)</small>
        </div>

        <div class="row" style="justify-content:flex-end; gap:.5rem;">
          <button type="button" onclick="document.getElementById('configDlg').hidden=true">Close</button>
          <button type="submit" style="background:#0a84ff; border-color:#0a84ff;">Save &amp; Connect</button>
        </div>
      </form>
    </div>
  </div>

<script>
////////////////////////////////////////////////////////////////////////////////
// 0) Utility & globals
////////////////////////////////////////////////////////////////////////////////
const st = localStorage;
const statusEl = document.getElementById('status');
const orientEl = document.getElementById('orient');
const cmdEl    = document.getElementById('cmd');

const cfgDlg   = document.getElementById('configDlg');
const srvInp   = document.getElementById('srv');
const pwInp    = document.getElementById('pw');
const rateSlider = document.getElementById('rateSlider');
const rateBox    = document.getElementById('rateBox');

const btnPerms = document.getElementById('btnPerms');
const btnCenter= document.getElementById('btnCenter');
const btnSettings = document.getElementById('btnSettings');
const btnHome  = document.getElementById('btnHome');

const imgColor = document.getElementById('imgColor');
const imgDepth = document.getElementById('imgDepth');
let urlColor = null, urlDepth = null;

const SIO_PATH = "/socket.io";  // change only if server uses custom path

let serverURL   = "";
let sharedPW    = "";
let jwtToken    = st.getItem('neck_jwt') || ""; // optional cached JWT (if ever used)
let socket      = null;

// orientation baseline + live values (deg)
let baseYaw=null, basePitch=null, baseRoll=null;
let yaw=0, pitch=0, roll=0;

// acceleration & transient translations
let accel = {x:0,y:0,z:0};
let trans = {Y:0,Z:0,H:0};

// streaming control
let sendIntervalMs = Number(st.getItem('neck_rate_ms') || 100); // default 100ms
let intervalTimer = null;
let pauseUntil = 0; // ms timestamp; while in the future, streaming is paused

// tuning
const GAIN_YAW   = 8;   // deg â†’ units
const GAIN_PITCH = 8;
const GAIN_ROLL  = 8;

const DECAY = 0.90;     // exponential decay for transients

// constraints/helpers
const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
const setStatus=(emoji)=>{ statusEl.textContent = emoji; };
const wrap180 = a => ((a+540)%360)-180;

function getRelativeAngles() {
  if (baseYaw==null || basePitch==null || baseRoll==null) return {X:0,P:0,R:0};
  const dYaw   = wrap180(yaw   - baseYaw);
  const dPitch = wrap180(pitch - basePitch);
  const dRoll  = wrap180(roll  - baseRoll);
  const X = clamp(-dYaw   * GAIN_YAW  , -400, 400); // negative look right, positive left
  const P = clamp( dPitch * GAIN_PITCH, -400, 400); // + up, - down
  const R = clamp( dRoll  * GAIN_ROLL , -400, 400); // - right tilt, + left tilt
  return {X,P,R};
}
function decay(v){ return Math.abs(v) < 1 ? 0 : v*DECAY; }
function now(){ return Date.now(); }

////////////////////////////////////////////////////////////////////////////////
// 1) iOS / browser sensor permissions
////////////////////////////////////////////////////////////////////////////////
async function requestSensorPermissions() {
  try {
    let p1 = (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function')
      ? await DeviceMotionEvent.requestPermission() : 'granted';
    let p2 = (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function')
      ? await DeviceOrientationEvent.requestPermission() : 'granted';
    if (p1 !== 'granted' || p2 !== 'granted') {
      alert('Motion/orientation permissions were not granted. On iOS, use Safari over HTTPS.');
      return false;
    }
    return true;
  } catch {
    return true;
  }
}
btnPerms.addEventListener('click', async () => {
  const ok = await requestSensorPermissions();
  if (ok) btnPerms.disabled = true;
});
if (!/iphone|ipad|ipod/i.test(navigator.userAgent)) btnPerms.disabled = true;

////////////////////////////////////////////////////////////////////////////////
// 2) settings modal (persist to localStorage)
////////////////////////////////////////////////////////////////////////////////
srvInp.value = st.getItem('neck_server') || "";
pwInp.value  = st.getItem('neck_pw')     || "";
rateSlider.value = String(sendIntervalMs);
rateBox.value    = (sendIntervalMs/1000).toFixed(2);

document.getElementById('cfgForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  st.setItem('neck_server', srvInp.value.trim());
  st.setItem('neck_pw',     pwInp.value.trim());
  cfgDlg.hidden = true;
  await boot();  // connect after saving
});

btnSettings.addEventListener('click', () => { cfgDlg.hidden = false; });

rateSlider.addEventListener('input', () => {
  sendIntervalMs = parseInt(rateSlider.value, 10);
  rateBox.value = (sendIntervalMs/1000).toFixed(2);
  st.setItem('neck_rate_ms', String(sendIntervalMs));
  scheduleTick();
});
rateBox.addEventListener('change', () => {
  let s = parseFloat(rateBox.value);
  if (Number.isNaN(s)) return;
  s = clamp(s, 0.01, 0.10);
  sendIntervalMs = Math.round(s * 1000);
  rateSlider.value = String(sendIntervalMs);
  st.setItem('neck_rate_ms', String(sendIntervalMs));
  scheduleTick();
});

if (srvInp.value && pwInp.value) {
  cfgDlg.hidden = true;
  boot(); // autoconnect on revisit
}

////////////////////////////////////////////////////////////////////////////////
// 3) live sensors
////////////////////////////////////////////////////////////////////////////////
window.addEventListener('deviceorientation', e => {
  if (e.alpha != null) {
    yaw   = e.alpha;   // 0..360
    pitch = e.beta;    // -180..180
    roll  = e.gamma;   // -90..90
    orientEl.textContent = `Yaw ${yaw.toFixed(0)}Â°  Pitch ${pitch.toFixed(0)}Â°  Roll ${roll.toFixed(0)}Â°`;
  }
}, true);

window.addEventListener('devicemotion', e => {
  let a = e.acceleration && (e.acceleration.x!=null) ? e.acceleration : e.accelerationIncludingGravity;
  if (a) accel = { x: a.x || 0, y: a.y || 0, z: a.z || 0 };
}, true);

btnCenter.addEventListener('click', () => {
  baseYaw = yaw; basePitch = pitch; baseRoll = roll;
});

////////////////////////////////////////////////////////////////////////////////
// 4) Home button: send HOME and pause streaming for 5 seconds
////////////////////////////////////////////////////////////////////////////////
btnHome.addEventListener('click', () => {
  if (!socket || socket.disconnected) return;
  // reset transient translations
  trans = {Y:0,Z:0,H:0};
  // show HOME and send
  cmdEl.textContent = "HOME";
  socket.emit('broadcast-message', { message: "HOME" });
  // pause streaming for 5 seconds
  pauseUntil = now() + 5000;
});

////////////////////////////////////////////////////////////////////////////////
// 5) command synthesis & streaming (adjustable interval)
////////////////////////////////////////////////////////////////////////////////
function tick() {
  if (!socket || socket.disconnected) return;
  if (now() < pauseUntil) return; // paused after HOME

  // map motion impulses â†’ transient translations, then decay toward 0
  //   forward/back  : accel.y -> Z (âˆ’ forward, + backward)
  //   up/down       : accel.z -> H (0..50)
  //   left/right    : accel.x -> Y (âˆ’ left, + right)
  trans.Z = clamp(decay(trans.Z + (-accel.y*10)), -400, 400);
  trans.H = clamp(decay(trans.H + ( accel.z* 2)),   0,  50);
  trans.Y = clamp(decay(trans.Y + ( accel.x*10)), -400, 400);

  const {X,P,R} = getRelativeAngles();
  const cmd = `X${X.toFixed(0)},Y${trans.Y.toFixed(0)},Z${trans.Z.toFixed(0)},` +
              `H${trans.H.toFixed(0)},S1,A1,R${R.toFixed(0)},P${P.toFixed(0)}`;
  cmdEl.textContent = cmd;

  socket.emit('broadcast-message', { message: cmd });
}

function scheduleTick() {
  if (intervalTimer) clearInterval(intervalTimer);
  intervalTimer = setInterval(tick, sendIntervalMs);
}
scheduleTick(); // start loop immediately; will no-op until connected

////////////////////////////////////////////////////////////////////////////////
// 6) networking helpers: bind per-socket handlers
////////////////////////////////////////////////////////////////////////////////
function wireCommonHandlers(s) {
  s.on('connect',      () => setStatus('ðŸŸ¢'));
  s.on('disconnect',   () => setStatus('ðŸ”´'));
  s.on('connect_error',() => setStatus('ðŸ”´'));
}

function updateImg(imgEl, oldUrlRefName, payload, mime) {
  // payload may be ArrayBuffer/Uint8Array/Blob
  const blob = payload instanceof Blob ? payload : new Blob([payload], { type: mime });
  const url = URL.createObjectURL(blob);
  imgEl.src = url;
  if (window[oldUrlRefName]) URL.revokeObjectURL(window[oldUrlRefName]);
  window[oldUrlRefName] = url;
}

function wireFrameHandlers(s) {
  // clean previous handlers to avoid dupes on reconnect
  s.off('frame-color'); s.off('frame-depth');

  s.on('frame-color', (payload) => {
    updateImg(imgColor, 'urlColor', payload, 'image/jpeg');
  });
  s.on('frame-depth', (payload) => {
    updateImg(imgDepth, 'urlDepth', payload, 'image/png');
  });
}

////////////////////////////////////////////////////////////////////////////////
// 7) networking: WS-only auth strategy
//    - Try JWT if present
//    - Else use {uuid,password} directly via WS auth
////////////////////////////////////////////////////////////////////////////////
function connectWS_withToken() {
  return new Promise((resolve,reject)=>{
    const s = io(serverURL, {
      path: SIO_PATH,
      auth: { token: jwtToken },       // JWT string
      transports: ['websocket']
    });
    let settled = false;
    wireCommonHandlers(s);
    wireFrameHandlers(s);

    s.on('connect', () => { socket = s; setStatus('ðŸŸ¢'); settled = true; resolve('token'); });
    s.on('connect_error',(err) => { if (!settled) { s.close(); reject(err); } });
  });
}
function connectWS_withPassword() {
  return new Promise((resolve,reject)=>{
    const uuid = 'phone-' + Date.now().toString(36);
    const s = io(serverURL, {
      path: SIO_PATH,
      auth: { uuid, password: sharedPW },
      transports: ['websocket']
    });
    let settled = false;
    wireCommonHandlers(s);
    wireFrameHandlers(s);

    s.on('connect', () => { socket = s; setStatus('ðŸŸ¢'); settled = true; resolve('password'); });
    s.on('connect_error',(err) => { if (!settled) { s.close(); reject(err); } });
  });
}

////////////////////////////////////////////////////////////////////////////////
async function boot() {
  serverURL = (st.getItem('neck_server') || "").trim().replace(/\/+$/, '');
  sharedPW  = (st.getItem('neck_pw')     || "").trim();
  if (!serverURL || !sharedPW) { cfgDlg.hidden = false; return; }

  setStatus('ðŸŸ¡');

  // iOS sensors require HTTPS
  if (!window.isSecureContext && /iphone|ipad|ipod/i.test(navigator.userAgent)) {
    alert("iOS sensors require HTTPS. Open this page via https.");
  }

  try {
    if (jwtToken) {
      await connectWS_withToken();
    } else {
      await connectWS_withPassword();
    }
  } catch {
    try { await connectWS_withPassword(); }
    catch (ee) { console.error('WS connect failed:', ee); setStatus('ðŸ”´'); }
  }

  // auto-calibrate once after 1s if not already done
  setTimeout(() => { if (baseYaw==null) btnCenter.click(); }, 1000);
}
</script>
</body>
</html>
